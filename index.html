<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Advanced Custom Code Editor with Enhanced Background & Colors</title>
  <style>


    

    #controlsContainer {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
    }

    #bgSelector, #colorSelector, #colorModeToggle {
      background: #1E1E1E;
      color: white;
      border: 1px solid #444;
      padding: 6px 10px;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      transition: border-color 0.25s ease, box-shadow 0.25s ease;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      flex-shrink: 0;
    }
    #bgSelector:hover, #colorSelector:hover,
    #bgSelector:focus, #colorSelector:focus,
    #colorModeToggle:hover, #colorModeToggle:focus {
      border-color: var(--tab-active-color, #007ACC);
      box-shadow: 0 0 10px var(--tab-active-color, #007ACC);
      outline: none;
    }

    #bgSelector {
      width: 160px;
    }
    #colorSelector {
      width: 40px;
      padding: 0;
      height: 32px;
      border-radius: 5px;
      filter: drop-shadow(0 0 4px var(--tab-active-color, #007ACC));
      transition: filter 0.3s ease;
    }
    #colorModeToggle {
      width: 160px;
      text-align: center;
      user-select: none;
    }

    #container {
      position: absolute;
      top: 42px; left: 0; right: 0; bottom: 0;
      z-index: 2;
      transition: margin-right 0.3s ease;
    }

    /* Transparent Monaco editor */
    .monaco-editor,
    .monaco-editor .margin,
    .monaco-editor .glyph-margin,
    .monaco-editor-background,
    .monaco-editor .lines-content {
      background: transparent !important;
      transition: color 0.5s ease;
    }

    /* Sliding workspace styles */
    #workspaceToggleBtn {
      padding: 6px 10px;
      background: #1E1E1E;
      border: 1px solid #444;
      border-radius: 5px;
      color: white;
      cursor: pointer;
      font-size: 14px;
      user-select: none;
      transition: border-color 0.25s ease, box-shadow 0.25s ease;
    }

    #workspaceToggleBtn:hover, #workspaceToggleBtn:focus {
      border-color: var(--tab-active-color, #007ACC);
      box-shadow: 0 0 10px var(--tab-active-color, #007ACC);
      outline: none;
    }

    #workspace {
      position: fixed;
      top: 42px; /* below tab bar */
      right: 0;
      width: 350px;
      height: calc(100% - 42px);
      background-color: #252526;
      box-shadow: -4px 0 12px rgba(0, 0, 0, 0.7);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 10;
      display: flex;
      flex-direction: column;
      color: white;
      font-family: monospace;
      padding: 12px;
    }

    #workspace.open {
      transform: translateX(0);
    }

    #workspaceHeader {
      font-weight: 700;
      font-size: 18px;
      margin-bottom: 12px;
      border-bottom: 1px solid #444;
      padding-bottom: 6px;
      user-select: none;
    }

    #fileName {
      font-weight: 600;
      margin-bottom: 8px;
    }

    #workspaceContent {
      flex: 1;
      background-color: #1E1E1E;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 12px;
      white-space: pre-wrap;
      overflow-y: auto;
      font-size: 14px;
    }


    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
      background-color: #1E1E1E;
      font-family: 'Segoe UI', sans-serif;
      transition: background-color 0.5s ease;
    }

    #bgCanvas {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
      pointer-events: none;
      filter: drop-shadow(0 0 8px rgba(0, 0, 0, 0.5));
      will-change: transform;
    }

   :root {
  --tab-bg: #252526;
  --tab-hover-bg: #333;
  --tab-active-color: #007ACC;
  --tab-color: #AAA;
  --tab-hover-color: #EEE;
  --close-btn-color: #777;
  --close-btn-hover-color: #e55353;
}

#tabBar {
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 42px;
  background: var(--tab-bg);
  z-index: 3;
  display: flex;
  align-items: center;
  padding: 0 12px;
  border-bottom: 1px solid #3C3C3C;
  user-select: none;
  font-weight: 600;
  gap: 12px;
  overflow-x: auto;
  scrollbar-width: thin;
  scrollbar-color: #555 transparent;
}

/* Webkit scrollbar for better look */
#tabBar::-webkit-scrollbar {
  height: 6px;
}
#tabBar::-webkit-scrollbar-track {
  background: transparent;
}
#tabBar::-webkit-scrollbar-thumb {
  background-color: #555;
  border-radius: 3px;
}

.tab {
  position: relative;
  padding: 8px 18px;
  background: transparent;
  color: var(--tab-color);
  cursor: pointer;
  border: none;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
  white-space: nowrap;
  flex-shrink: 0;
  outline-offset: 2px;
  transition: color 0.3s ease;
}

/* Animated underline */
.tab::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 20%;
  width: 60%;
  height: 2.5px;
  background: transparent;
  border-radius: 2px 2px 0 0;
  transition: background-color 0.3s ease, transform 0.3s ease;
  transform-origin: center;
  transform: scaleX(0);
}

.tab:hover {
  color: var(--tab-hover-color);
}

.tab:hover::after {
  background-color: var(--tab-hover-color);
  transform: scaleX(1);
}

.tab.active {
  color: var(--tab-active-color);
  font-weight: 700;
}

.tab.active::after {
  background-color: var(--tab-active-color);
  transform: scaleX(1);
}

/* Close button hidden by default, show on tab hover */
.tab .close-btn {
  opacity: 0;
  pointer-events: none;
  font-weight: 700;
  color: var(--close-btn-color);
  cursor: pointer;
  user-select: none;
  font-size: 12px;
  padding: 0 6px;
  border-radius: 3px;
  transition: opacity 0.2s ease, color 0.2s ease;
}

.tab:hover .close-btn {
  opacity: 1;
  pointer-events: auto;
}

.tab .close-btn:hover {
  color: var(--close-btn-hover-color);
}

/* Keyboard focus visible */
.tab:focus-visible {
  outline: 2px solid var(--tab-active-color);
  outline-offset: 2px;
}

#addTabBtn {
  padding: 0 12px;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  color: var(--tab-color);
  background: transparent;
  border: none;
  user-select: none;
  flex-shrink: 0;
  transition: color 0.25s ease;
}

#addTabBtn:hover,
#addTabBtn:focus-visible {
  color: var(--tab-active-color);
  outline: none;
}


    #controlsContainer {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
    }

    #bgSelector, #colorSelector, #colorModeToggle {
      background: #1E1E1E;
      color: white;
      border: 1px solid #444;
      padding: 6px 10px;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      transition: border-color 0.25s ease, box-shadow 0.25s ease;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      flex-shrink: 0;
    }
    #bgSelector:hover, #colorSelector:hover,
    #bgSelector:focus, #colorSelector:focus,
    #colorModeToggle:hover, #colorModeToggle:focus {
      border-color: var(--tab-active-color, #007ACC);
      box-shadow: 0 0 10px var(--tab-active-color, #007ACC);
      outline: none;
    }

    #bgSelector {
      width: 160px;
    }
    #colorSelector {
      width: 40px;
      padding: 0;
      height: 32px;
      border-radius: 5px;
      filter: drop-shadow(0 0 4px var(--tab-active-color, #007ACC));
      transition: filter 0.3s ease;
    }
    #colorModeToggle {
      width: 160px;
      text-align: center;
      user-select: none;
    }

    #container {
      position: absolute;
      top: 42px; left: 0; right: 0; bottom: 0;
      z-index: 2;
    }

    /* Transparent Monaco editor */
    .monaco-editor,
    .monaco-editor .margin,
    .monaco-editor .glyph-margin,
    .monaco-editor-background,
    .monaco-editor .lines-content {
      background: transparent !important;
      transition: color 0.5s ease;
    }
  </style>
</head>
<body>
  <canvas id="bgCanvas"></canvas>

  <div id="tabBar">
    <!-- tabs inserted dynamically -->
    <button id="addTabBtn" title="Add new tab">+</button>
    <div id="controlsContainer">
      <select id="bgSelector" title="Select background animation">
        <option value="advanced">Nebula Glow</option>
        <option value="dotsLines">Dots & Lines Enhanced</option>
        <option value="matrix">Matrix Rain</option>
        <option value="wave">Sine Wave Glow</option>
        <option value="starsTwinkle">Twinkling Stars</option>
        <option value="purpleParticles">Purple Particles</option>
        <option value="expandingCircles">Expanding Circles</option>
        <option value="Engine6.0 Ai">Engine6.0 Ai</option>
      </select>

      <input id="colorSelector" type="color" value="#007ACC" title="Pick a color" />

      <button id="colorModeToggle" title="Toggle color mode">
        Color Mode: Background
      </button>
    </div>
  </div>

  <div id="container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
  <script>
    require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });

    let editor, currentTab = 'Tab1';
    const tabContents = {
      'Tab1': '-- Lua code here\nprint("Hello from Tab 1")',
      'Tab2': '-- Another tab\nprint("Hello from Tab 2")'
    };

    const tabBar = document.getElementById('tabBar');
    const addTabBtn = document.getElementById('addTabBtn');

    function createTab(name) {
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.innerText = name;
      tab.id = `tab-${name}`;
      tab.onclick = () => switchTab(name);

      // Close button
      const closeBtn = document.createElement('span');
      closeBtn.className = 'close-btn';
      closeBtn.innerText = 'Ã—';
      closeBtn.title = `Close ${name}`;
      closeBtn.onclick = e => {
        e.stopPropagation();
        closeTab(name);
      };

      tab.appendChild(closeBtn);
      tabBar.insertBefore(tab, addTabBtn);
    }

    function switchTab(name) {
      if (name === currentTab) return;
      if (editor) tabContents[currentTab] = editor.getValue();
      currentTab = name;
      if (editor) editor.setValue(tabContents[name] || '');
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      const newActive = document.getElementById(`tab-${name}`);
      if (newActive) newActive.classList.add('active');
    }

    function closeTab(name) {
      if (!(name in tabContents)) return;
      delete tabContents[name];
      const tab = document.getElementById(`tab-${name}`);
      if (tab) tab.remove();

      if (currentTab === name) {
        // Switch to another tab if available
        const remainingTabs = Object.keys(tabContents);
        if (remainingTabs.length > 0) {
          switchTab(remainingTabs[0]);
        } else {
          // No tabs left, create a new one
          createNewTab();
        }
      }
    }

    function createNewTab() {
      let index = 1;
      while (tabContents[`Tab${index}`]) index++;
      const name = `Tab${index}`;
      tabContents[name] = '-- New Lua tab';
      createTab(name);
      switchTab(name);
    }

    addTabBtn.onclick = createNewTab;

    function initTabs() {
      Object.keys(tabContents).forEach(createTab);
      switchTab(currentTab);
    }

    // Monaco editor init
    require(['vs/editor/editor.main'], function () {
      editor = monaco.editor.create(document.getElementById('container'), {
        value: tabContents[currentTab],
        language: 'lua',
        theme: 'vs-dark',
        fontSize: 16,
        fontFamily: "'Fira Code', monospace",
        automaticLayout: true,
        minimap: { enabled: false },
        scrollbar: { vertical: 'auto', horizontal: 'auto' },
        overviewRulerLanes: 0,
        lineNumbersMinChars: 3,
        lineDecorationsWidth: 4,
        renderLineHighlight: 'all',
        cursorBlinking: 'phase',
        smoothScrolling: true,
        renderIndentGuides: true,
        folding: true,
        // Make editor background transparent
        extraEditorClassName: 'transparent-editor',
      });

      initTabs();
      setBackground(bgSelector.value);
      setEditorColor(colorSelector.value);

      // Update editor color on color change
      colorSelector.addEventListener('input', () => {
        setEditorColor(colorSelector.value);
      });

      // Background change
      bgSelector.addEventListener('change', () => {
        setBackground(bgSelector.value);
      });

      // Color mode toggle
      colorModeToggle.addEventListener('click', () => {
        colorMode = colorMode === 'background' ? 'foreground' : 'background';
        colorModeToggle.textContent = `Color Mode: ${colorMode.charAt(0).toUpperCase() + colorMode.slice(1)}`;
        updateColors();
      });

      // Initialize animation
      animate();

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    });

    // Background animation code

    const canvas = document.getElementById('bgCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const bgSelector = document.getElementById('bgSelector');
    const colorSelector = document.getElementById('colorSelector');
    const colorModeToggle = document.getElementById('colorModeToggle');

    let colorMode = 'background'; // 'background' or 'foreground'
    let currentBg = 'advanced';
    let editorColor = colorSelector.value;

    function setEditorColor(hexColor) {
      editorColor = hexColor;
      updateColors();
    }

    function updateColors() {
      if (colorMode === 'background') {
        document.body.style.backgroundColor = editorColor;
        document.documentElement.style.setProperty('--tab-active-color', editorColor);
        if (editor) editor.updateOptions({ theme: createTheme(editorColor, 'background') });
      } else {
        document.body.style.backgroundColor = '#1E1E1E';
        document.documentElement.style.setProperty('--tab-active-color', editorColor);
        if (editor) editor.updateOptions({ theme: createTheme(editorColor, 'foreground') });
      }
    }

    function createTheme(color, mode) {
      const base = mode === 'background' ? '#1E1E1E' : '#000000';
      return {
        base: 'vs-dark',
        inherit: true,
        rules: [
          { token: '', foreground: color.replace('#', '') },
          { token: 'keyword', foreground: color.replace('#', ''), fontStyle: 'bold' },
          { token: 'comment', foreground: '888888', fontStyle: 'italic' },
          { token: 'string', foreground: 'D69D85' },
          { token: 'number', foreground: 'B5CEA8' },
        ],
        colors: {
          'editor.background': mode === 'background' ? base : '#1E1E1E00',
          'editor.foreground': color,
          'editorCursor.foreground': color,
          'editorLineNumber.foreground': '555555',
          'editorLineNumber.activeForeground': color,
          'editor.selectionBackground': color + '44',
          'editor.inactiveSelectionBackground': color + '22',
          'editorIndentGuide.background': '404040',
          'editorIndentGuide.activeBackground': color,
        }
      };
    }

    // --- Background animations ---

    // Particle utilities
    class Particle {
      constructor(x, y, vx, vy, radius, color, alpha=1) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = radius;
        this.color = color;
        this.alpha = alpha;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;

        // Bounce
        if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
      }

      draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
      }
    }

    // Multiple backgrounds defined here
    // Each returns a function to animate the frame

    // 1. Nebula Glow (advanced)
    function nebulaGlow() {
      const particles = [];
      for(let i=0; i<150; i++) {
        particles.push(new Particle(
          Math.random()*canvas.width,
          Math.random()*canvas.height,
          (Math.random()-0.5)*0.3,
          (Math.random()-0.5)*0.3,
          1 + Math.random()*2,
          `hsl(${Math.random()*360}, 60%, 70%)`,
          0.4 + Math.random()*0.6
        ));
      }

      return function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(20,20,30,0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        particles.forEach(p => {
          p.update();
          p.draw();
        });
      };
    }

    // 2. Dots & Lines Enhanced
    function dotsLinesEnhanced() {
      const points = [];
      const maxDist = 150;
      for(let i=0; i<80; i++) {
        points.push({
          x: Math.random()*canvas.width,
          y: Math.random()*canvas.height,
          vx: (Math.random()-0.5)*1,
          vy: (Math.random()-0.5)*1
        });
      }

      return function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(10,10,10,0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for(let i=0; i<points.length; i++) {
          const p = points[i];
          p.x += p.vx;
          p.y += p.vy;
          if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
          if (p.y < 0 || p.y > canvas.height) p.vy *= -1;

          ctx.beginPath();
          ctx.fillStyle = '#AAA';
          ctx.arc(p.x, p.y, 3, 0, 2*Math.PI);
          ctx.fill();

          // Connect close points
          for(let j=i+1; j<points.length; j++) {
            const p2 = points[j];
            const dist = Math.hypot(p.x-p2.x, p.y-p2.y);
            if(dist < maxDist) {
              ctx.beginPath();
              ctx.strokeStyle = `rgba(170,170,170,${1 - dist/maxDist})`;
              ctx.lineWidth = 1;
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
          }
        }
      };
    }

    // 3. Matrix Rain
    function matrixRain() {
      const fontSize = 18;
      const columns = Math.floor(canvas.width / fontSize);
      const drops = new Array(columns).fill(1);
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()';

      return function() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#0F0';
        ctx.font = `${fontSize}px monospace`;

        for (let i = 0; i < drops.length; i++) {
          const text = chars.charAt(Math.floor(Math.random() * chars.length));
          ctx.fillText(text, i * fontSize, drops[i] * fontSize);

          if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
            drops[i] = 0;
          }
          drops[i]++;
        }
      };
    }

    // 4. Sine Wave Glow
    function sineWaveGlow() {
      const waves = [];
      const waveCount = 5;
      for(let i=0; i<waveCount; i++) {
        waves.push({
          amplitude: 20 + 10*i,
          frequency: 0.01 + 0.005*i,
          phase: Math.random()*Math.PI*2,
          speed: 0.02 + 0.01*i,
          yOffset: canvas.height/2 + (i - waveCount/2)*30,
          color: `hsl(${i*60}, 70%, 60%)`
        });
      }

      let time = 0;

      return function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(10,10,10,0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        waves.forEach(wave => {
          ctx.beginPath();
          ctx.strokeStyle = wave.color;
          ctx.lineWidth = 2;
          ctx.shadowColor = wave.color;
          ctx.shadowBlur = 10;

          for(let x=0; x<canvas.width; x++) {
            const y = wave.yOffset + wave.amplitude * Math.sin(wave.frequency * x + wave.phase + time * wave.speed);
            if (x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }

          ctx.stroke();
        });

        time += 1;
      };
    }

    // 5. Twinkling Stars
    function twinklingStars() {
      const stars = [];
      for(let i=0; i<100; i++) {
        stars.push({
          x: Math.random()*canvas.width,
          y: Math.random()*canvas.height,
          radius: Math.random()*1.5,
          alpha: Math.random(),
          alphaChange: (Math.random()*0.02) + 0.005,
          color: 'white'
        });
      }

      return function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#000011';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        stars.forEach(star => {
          star.alpha += star.alphaChange;
          if (star.alpha >= 1 || star.alpha <= 0) star.alphaChange *= -1;

          ctx.beginPath();
          ctx.fillStyle = `rgba(255,255,255,${star.alpha})`;
          ctx.shadowColor = `rgba(255,255,255,${star.alpha})`;
          ctx.shadowBlur = 6;
          ctx.arc(star.x, star.y, star.radius, 0, 2*Math.PI);
          ctx.fill();
        });
      };
    }

    // 6. Purple Particles
    function purpleParticles() {
      const particles = [];
      for(let i=0; i<120; i++) {
        particles.push(new Particle(
          Math.random()*canvas.width,
          Math.random()*canvas.height,
          (Math.random()-0.5)*0.5,
          (Math.random()-0.5)*0.5,
          1 + Math.random()*1.5,
          'purple',
          0.5 + Math.random()*0.5
        ));
      }

      return function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(15,0,30,0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        particles.forEach(p => {
          p.update();
          p.draw();
        });
      };
    }

    // 7. Expanding Circles
    function expandingCircles() {
      const circles = [];
      for(let i=0; i<30; i++) {
        circles.push({
          x: Math.random()*canvas.width,
          y: Math.random()*canvas.height,
          radius: Math.random()*20 + 10,
          maxRadius: 60 + Math.random()*40,
          speed: 0.5 + Math.random()*0.5,
          alpha: 0.4,
          growing: true,
          color: `hsl(${Math.random()*360}, 60%, 70%)`
        });
      }

      return function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(20,20,25,0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        circles.forEach(c => {
          if(c.growing) {
            c.radius += c.speed;
            c.alpha -= 0.007;
            if(c.radius >= c.maxRadius) {
              c.growing = false;
              c.alpha = 0.4;
            }
          } else {
            c.radius -= c.speed;
            c.alpha += 0.007;
            if(c.radius <= 10) {
              c.growing = true;
              c.radius = 10;
            }
          }
          ctx.beginPath();
          ctx.strokeStyle = `rgba( ${parseHSL(c.color).join(',')},${c.alpha})`;
          ctx.lineWidth = 2;
          ctx.shadowColor = c.color;
          ctx.shadowBlur = 10;
          ctx.arc(c.x, c.y, c.radius, 0, 2*Math.PI);
          ctx.stroke();
        });
      };
    }

    // Helper: parse HSL string into array [h, s%, l%]
    function parseHSL(hsl) {
      // hsl(360, 60%, 70%) -> [360, 60%, 70%]
      const m = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
      if (!m) return [0, 0, 0];
      return [m[1], m[2]+'%', m[3]+'%'];
    }

    let animateFunc = null;

    function setBackground(name) {
      currentBg = name;
      switch (name) {
        case 'advanced':
          animateFunc = nebulaGlow();
          break;
        case 'dotsLines':
          animateFunc = dotsLinesEnhanced();
          break;
        case 'matrix':
          animateFunc = matrixRain();
          break;
        case 'wave':
          animateFunc = sineWaveGlow();
          break;
        case 'starsTwinkle':
          animateFunc = twinklingStars();
          break;
        case 'purpleParticles':
          animateFunc = purpleParticles();
          break;
        case 'expandingCircles':
          animateFunc = expandingCircles();
          break;
        default:
          animateFunc = nebulaGlow();
      }
    }

    function animate() {
      if (animateFunc) animateFunc();
      requestAnimationFrame(animate);
    }

  </script>
</body>
</html>